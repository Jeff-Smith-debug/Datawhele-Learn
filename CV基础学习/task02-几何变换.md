@[TOC](几何变换)

**图像变换的本质是将像素点的坐标通过某一种函数关系，映射到另外的位置**
几何变换的原理大多都是相似，只是变换矩阵不同，这里以最常用的平移和旋转为例进行学习。
在深度学习领域，我们常用平移、旋转、镜像等操作进行数据增广；
在传统CV领域，由于某些拍摄角度的问题，我们需要对图像进行矫正处理，而几何变换正是这个处理过程的基础；
# 1 心中问题
1：变换的形式（公式）是什么？ 下面有公式
2：旋转中心是什么？毕竟以不同位置为旋转中心得到的结果是不一样的。
3：采用前向映射还是反向映射？ (反向映射更为有效)
4：采用反向映射后，采用何种插值算法？ 最常用的的是双线性插值，OpenCV也是默认如此。

# 2 学习目标
了解几何变换的概念与应用；平移、旋转的原理
OpenCV框架下实现平移、旋转操作
掌握在OpenCV框架下实现平移、旋转操作

# 3 算法理论介绍
## 3.1 变换矩阵
式中的T就是变换矩阵，其中 (v,w)为原坐标，(x,y) 为变换后的坐标，不同的变换对应不同的矩阵：
 
一些常见的变换矩阵及作用如下表：
 
**我们只需要根据自己的目的选择不同变换矩阵就可以了**

## 3.2 坐标系变换
### 3.2.1 变换中心
对于缩放、平移可以以图像坐标原点（图像左上角为原点）为中心变换，这不用坐标系变换，直接按照一般形式计算即可；
而对于旋转和偏移，一般是以图像中心为原点，那么这就涉及坐标系转换；
对于旋转和偏移，设计坐标系变换，需要三步：
1、将输入原图图像坐标转换为笛卡尔坐标系；
2、进行旋转计算。旋转矩阵前面已经给出了；
3、将旋转后的图像的笛卡尔坐标转回图像坐标	
### 3.2.2 图像坐标系与笛卡尔坐标系
什么是图像坐标系和笛卡尔坐标系：
 
两者之间关系：
 
令图像表示为M×N的矩阵，对于点A而言，两坐标系中的坐标分别是(0，0)和(-N/2,M/2)，则图像某像素点(x',y')转换为笛卡尔坐标（x,y）转换关系为，x为列，y为行：
则从图像坐标系到笛卡尔坐标系变换为：
	x=x'-N/2
	y=-y'+M/2
从笛卡尔坐标系变换为图像坐标系为：
	x'=x+N/2
	y'=-y+M/2
根据前面说的3个步骤（3次变换），旋转(顺时针旋转)的变换形式就为，3次变换就有3个矩阵：
**记住 矩阵变换是 先后顺序的，就像先穿袜子再穿鞋一样**

## 3.3 前向映射和反向映射
 
像素点的坐标变换
公式(1)我们已知原图像到目标图像的坐标变换(f(x,y),g(x,y))，因此我们可以知道原图像的一点在变换后在目标图像的位置，我们称为向前映射。
相反，公式(2)中我们知道目标图像的一点(x’,y’)在变换前在原图像上的位置(f−1(x′,y′),g−1(x′,y′))(f−1(x′,y′),g−1(x′,y′))，我们称为向后映射。
### 3.3.2 前向映射
前向映射就是根据原图像素坐标用变换公式直接算出输出图像相应像素的空间位置；
导致问题：可能会有多个像素坐标映射到输出图像的同一位置；，也可能输出图像的某些位置完全没有相应的输入图像像素与它匹配，也就是没有被映射到，造成有规律的空洞（黑色的蜂窝状）
### 3.3.3 后向映射
扫描输出图像的位置(x,y)，通过 Image （为T的逆矩阵）计算输入图像对应的位置 (v,w)，再通过再原图像的插值方法决来定输出图像该位置的灰度值；

### 3.4 映射和插值
通常情况下，一个整数位置(x,y)经过图像变换后，往往都位于非整数位置。此时就要采用插值技术。此时对于向前映射和向后映射，需要采取不同的策略。
### 3.4.1 前向映射
 
输入图像上整数点坐标映射到输出图像之后，变成了非整数点坐标。因此，需要将其像素值按一定权重分配到其周围四个像素点上。对于输出图像而言，其整数点像素值周围会有很多输入图像像素映射过来，每个到其周围的非整数点像素值都会分配一定的灰度值到它上面，将这些分配而来的像素值叠加，就是输出图像整数点位置的像素值。  由于这个分配、叠加的特性，向前映射法有时也叫像素移交映射。
缺点：对于向前映射而言，输出图像某一点的像素值不能直接得到，需要遍历输入图像的所有像素值，对其进行坐标变换，分配像素值到整数位置，才能得到输出图像各像素点的像素值。
### 3.4.2 后向映射
 
向后映射法就比较直观：输出图像的像素点（x',y'）在整数点位置上，映射到变换前的输入图像上的像素点（x,y），一般就是个非整数点的位置，在输入图像上的这个像素点(x,y)--再利用其周围整数点位置的输入图像像素值进行插值，就得到了该点的像素值。
我们遍历输出图像，经过坐标变换、插值两步操作，我们就能将其像素值一个个地计算出来，因此向后映射又叫图像填充映射。
### 3.4.3 插值算法
一般默认都采用双线性插值算法；
**什么时候采用哪种变换？**
向后映射比较直观，计算量也小，我们经常使用的图像变换都是采用向后映射的方法来处理。但向后映射需要知道变换的反变换公式，在上面旋转变换的情况，反变换很容易求出来。但在有些变换比较复杂的场合，这个反变换是很难得到的。此时就需要采用前向映射的方法进行变换了。

# 4 代码实践
Python环境下，调用OpenCV的API；
```python
# -*- coding: utf-8 -*-
"""
Created on Thu Apr 23 22:54:53 2020
计算机视觉基础实现：调用OpenCV的API来实现几何变换
@author: Administrator
"""
# %% 读取图像
import cv2
img=cv2.imread('lena.bmp')

# %% 旋转变换
# 第一参数指定旋转圆点；第二个参数指定旋转角度 第三个参数指定缩放比例
# 

rows,cols ,channel = img.shape

M=cv2.getRotationMatrix2D((rows/2,cols/3),90,0.4) #获得变换矩阵
dst = cv2.warpAffine(img,M,(cols,rows))

cv2.imshow('img',img)
cv2.imshow('rotation',dst)
cv2.waitKey(0)
cv2.destroyAllWindows()

# %% 仿射变换
# 仿射变换是一种二维坐标到二维坐标之间的线性变换，并保持二维图形的“平直性”。
# 转换前平行的线，在转换后依然平行。

# getAffineTransform() 这个函数里的参数代表什么意思？
import cv2
import numpy as np
from matplotlib import pyplot as plt

img=cv2.imread('lena.bmp')


rows,cols, channel = img.shape

pst1 = np.float32([[50,50],[200,50],[50,200]])
pst2 = np.float32([[10,100],[200,50],[100,250]])

M = cv2.getAffineTransform(pst1,pst2)
dst =cv2.warpAffine(img,M,(cols,rows))

# 这个显示图像特别像 MATLAB
plt.subplot(121);plt.imshow(img);plt.title('input')
plt.subplot(122);plt.imshow(dst);plt.title('output')
plt.show()

# %% 平移代码实践
import cv2 
import numpy as np

img = cv2.imread('lena.bmp')
rows,cols,channels =img.shape

M = np.float32([[1,0,100],[0,1,50]])
dst = cv2.warpAffine(img,M,(cols,rows))

cv2.imshow('img',img)
cv2.imshow('rotation',dst)
cv2.waitKey(0)
cv2.destroyAllWindows()
```



